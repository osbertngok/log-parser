// go generate ./...
// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT

package models
import (
    "bytes"
    "fmt"
    "math"
    "time"
    "strconv"
)

{{ .RecordClass }}

func handleFloat64(buffer *bytes.Buffer, f float64) {
    floor := math.Floor(f)
    if math.Abs(f - floor) < 0.000001 {
        buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatFloat(f, 'f', 0, 64)))
    } else {
        buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatFloat(f, 'f', 6, 64)))
    }
}

func handleString(buffer *bytes.Buffer, s string) {
    buffer.WriteString(fmt.Sprintf("\"%s\",", s))
}

func handleBool(buffer *bytes.Buffer, b bool) {
    buffer.WriteString(fmt.Sprintf("%s,", boolToIntString(b)))
}

func boolToIntString(b bool) string {
    if b {
        return "1"
    } else {
        return "0"
    }
}

func (r *Record) MarkBitmap(index uint64) {
	quotient := index / 64 // integer division, decimals are truncated
	remainder := index % 64
	switch quotient {
	case 0:
		r.Bitmap0 |= 1 << remainder
	case 1:
		r.Bitmap1 |= 1 << remainder
	case 2:
		r.Bitmap2 |= 1 << remainder
	case 3:
		r.Bitmap3 |= 1 << remainder
	case 4:
		r.Bitmap4 |= 1 << remainder
	case 5:
		r.Bitmap5 |= 1 << remainder
	case 6:
		r.Bitmap6 |= 1 << remainder
	case 7:
		r.Bitmap7 |= 1 << remainder
	case 8:
		r.Bitmap8 |= 1 << remainder
	case 9:
		r.Bitmap9 |= 1 << remainder
	}
}

func (r *Record) ToCSV() string {
    var buffer bytes.Buffer

    buffer.WriteString(fmt.Sprintf("\"%s\",", r.EventDate.Format("2006-01-02")))
    buffer.WriteString(fmt.Sprintf("\"%s\",", r.EventTime.Format("2006-01-02 15:04:05")))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatInt(r.Microsecond, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatInt(r.ControllerNo, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap0, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap1, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap2, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap3, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap4, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap5, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap6, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap7, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap8, 10)))
    buffer.WriteString(fmt.Sprintf("%s,", strconv.FormatUint(r.Bitmap9, 10)))

    {{ range .Table.Data }}
        // {{ .Index }}
        {{ if eq .ValueType "float64" }}
            handleFloat64(&buffer, r{{ keyChainsToGoFields .KeyChains }})
        {{ end }}
        {{ if eq .ValueType "string" }}
            handleString(&buffer, r{{ keyChainsToGoFields .KeyChains }})
        {{ end }}
        {{ if eq .ValueType "bool" }}
            handleBool(&buffer, r{{ keyChainsToGoFields .KeyChains }})
        {{ end }}
        {{ if eq .ValueType "mixed" }}
            handleString(&buffer, r{{ keyChainsToGoFields .KeyChains }})
        {{ end }}
    {{ end }}

    ret := buffer.String()

    return ret[:len(ret)-1]
}